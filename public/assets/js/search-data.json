{"0": {
    "doc": "Assignment",
    "title": "Assignment",
    "content": "{% assign project = site.data.project.project3 %} {% include due_date.html project=project%} {% if project.changelog %} {% include changelog.html project=project %} {% endif %} # Project 3: {{page.title}} Your assignment is to implement a B-Tree, that will be used by a \"database\" to quickly retrieve data. We will be providing some starter code, but that is mainly the template setup. You are free to design your own implementations as you see fit, as long as you do not change the provided interface. That means you cannot change the function signatures we give you (including the constructors). Your B-Tree MUST fulfill the interface below. All functions return a boolean showing their success or failure. The return of the value happens through an \"out parameter\". We discuss those in their own section. ```c++ template class BTree { int m_Degree; int m_LeafSize; public: BTree(int m, int l) : m_Degree(m) , m_LeafSize(l) {} bool try_add(const TKey& key, const TIndex& inIndex) { return false; } bool try_find(const TKey& key, TIndex& outIndex) const { return true; } bool try_update(const TKey& key, const TIndex& inIndex) const { return false; } bool try_delete(const TKey& key) { return false; } }; ``` Please note that we do not show a Node class here. You will need such a class, but we discuss it in a different section. While designing your tree, you can use recursion and iteration as you see fit. Trees are inherently recursive structures, so you should often find yourself using that. But some things are easier to do iteratively! . ",
    "url": "/docs/project3/assignment.html",
    "relUrl": "/docs/project3/assignment.html"
  },"1": {
    "doc": "B-Trees",
    "title": "B-Trees",
    "content": "{% assign project = site.data.project.project3 %} {% include due_date.html project=project%} {% if project.changelog %} {% include changelog.html project=project %} {% endif %} # Project 3: {{page.title}} You should already be familiar with the theory on B-Trees. Reminder that you can find Professor Lupoli's playlist on YouTube, and embedded below. To avoid having to deal with real databases and hardware your trees will have to work in a particular way. Specifically, your trees will have to use keys just like the videos, but the data they are storing will be indexes that the \"Database\" will use to find the real records. Please note that an index can be a complex data type, instead of an integer. Do not worry, we will have examples and give you some classes to work with (just like we did in project 2)! . In this assignment you will NOT have to worry about the calculation of optimal M and L. You will be accepting those parameters as arguments in your tree's constructor and using them. ## The power of a name Before we get into the requirements, let's go over some nomenclature so everybody is on the same page. Let's take a look at the picture below. | Everything red is a node, and specifically an \"internal node\". In the picture below you have 3 internal nodes. | Everything colored light blue is a key. Notice how a node is NOT a key. A node does contain some keys though! | Everything colored green is a branch. Notice how a node might have some branches, but they are also \"outside\" the node. That's because they symbolize a relationship between nodes. | Everything colored orange is also a node, but this time it is a data node or data leaf. | Everything in white color is a record, or data. Notice how 5 is both a key, and part of a record. These two are semantically different! | Finally, everything inside the yellow line is the whole B-Tree! | . I only included a single data leaf for brevity. You would normally have a lot more. Also in your implementation, each record will be some form of index that the database will use. You don't care how it will be used. All you care about, is that there should be a Key == Record operator. The classes we give you will provide that operator. In the above diagram we denote a difference between an internal node and a leaf node. Implementation wise, those two could be the same class, different classes, or different classes where Leaf inherits from Node. This is a design decision that you have to make! ",
    "url": "/docs/project3/b-trees.html",
    "relUrl": "/docs/project3/b-trees.html"
  },"2": {
    "doc": "BTree::BTree",
    "title": "BTree::BTree",
    "content": "{% assign project = site.data.project.project3 %} {% include due_date.html project=project%} {% if project.changelog %} {% include changelog.html project=project %} {% endif %} # BTree::BTree ```c++ BTree::BTree(int m, int l) ``` ## Description Creates a new BTree, the given arguments are m and l from the lectures. You must not modify the signature. You can however add more stuff (i.e. the root) in the initializer list , or more logic in the body of the constructor. If you add more in the initializer list, it must be in the order they are declared as members. We first declared m_Degree and then m_LeafSize so we put them in that order in the list! . ## Parameters * **m**: The degree of the tree. Each node in the tree will have up to m children and m-1 keys * **l**: How many data items a data leaf can hold. ",
    "url": "/docs/project3/function_descriptions/constructor.html",
    "relUrl": "/docs/project3/function_descriptions/constructor.html"
  },"3": {
    "doc": "Designing nodes",
    "title": "Designing nodes",
    "content": "{% assign project = site.data.project.project3 %} {% include due_date.html project=project%} {% if project.changelog %} {% include changelog.html project=project %} {% endif %} # Project 3: {{page.title}} ## General guidelines Designing your nodes is something that needs to make sense to you and you can understand. That being said, you should try to write readable code, and not a nest of if/else and variables named `a` and `b`. Failing that you should leave comments on __why__ you are doing things. Comments like `Get child` don't really help. I also recommend making small functions focusing on one thing. Take a look at the next example, and think of which is more readable. Obviously we are omitting some things here. But the more complex your code is, the more you have to gain from this! ```c++ TIndex outIndex; TKey key; for(int i = 0; i Your nodes WILL have to be templated on the key and index as well! ## General Ideas B-Trees grow from the bottom up. That means you probably want to keep track of each node's parent on top of each node's children. Another property that might come up a lot is the height. Recall that a leaf has a height of 0. Maybe you want to keep track of it. Maybe you want to use it as a decreasing value in recursion, to detect a leaf. ## Design Ideas Next we will go over some design ideas. Please note that this is just to get you started, and obviously doesn't cover everything. You will have to expand on these. Also, it is VERY possible for you to come up with different designs. That is totally fine as well. Just please leave some comments on _how_ your nodes work and _why_. ### Idea 1: Single Node class In this design you have a single node class and you use flags to treat it as a leaf or internal node. For instance, you have a boolean to denote if the node is a leaf and every node has a vector for \"items\". But the vector is populated for leaves only. This potentially wastes quite a bit of memory. You can see an example below: ```c++ template class Node { private: bool m_IsLeaf; std::vector m_Keys; std::vector*> m_Children; std::vector m_Data; }; ``` ### Idea 2: Different Node classes This is a simple extension to the above. In _my_ opinion this only introduces more pain, over the previous idea. But remember, it is all about what makes sense to you, so you can implement it! You either have your m_Children vector populated and m_Leaves is empty, or the other way around. ```c++ template class Leaf { private: std::vector m_Data; }; template class Node { private: std::vector m_Keys; std::vector*> m_Children; // You either have these std::vector*> m_Leaves; // OR you either have these }; ``` ### Idea 3: Inheritance! This is the most \"elegant\" solution, but you might not feel comfortable with it. It is definitely the most OOP solution. LeafNode is a Node, so it gets access to all of its protected and public members and that adds Data on top. Furthermore we will override the behavior of `IsLeaf` so `m_Children[i]->IsLeaf()` will return true or false as expected. This is called polymorphism from your 202 class. Please note the constructors and destructors. They **MUST** be like that. Furthermore, `arguments for LeafNode` can include `arguments for Node`. ```c++ template class Node { protected: std::vector m_Keys; // Children can be Node or LeafNode std::vector*> m_Children; public: Node(/*arguments_for_node*/); virtual Node(); virtual bool IsLeaf() const { return false; } }; template class LeafNode: public Node { private: std::vector m_Data; public: LeafNode(/*arguments for LeafNode*/) : Node(/*arguments for Node*/) /*, other stuff for LeafNode here*/ {} virtual LeafNode(); // Notice how we override the behavior of Node here virtual bool IsLeaf() const override { return true; } }; ``` ### Idea 4: Nodes and entries(?) This idea can be combined with the rest pretty easily. Basically, your Node will have a private struct that can have keys and the next/previous link to a child. This way you can reduce the number of vectors you have to juggle around. I named the struct `Entry` because I am that imaginative. But you might want to use another name. Let's look at a concrete example though. We will revisit this picture. Let's say that we have the first node there at the top. An entry would have a key of 12, previousBranch would be a pointer to the bottom left node, and next branch would be a pointer to the bottom middle node. The next entry would have a key of 20 and so on and so forth. Again this is just an idea, and might warrant a lot of refinement. For instance think of the entry when you do not have a previous or next branch. ```c++ template class Node { private: struct Entry { TKey key; Node* previousBranch; Node* nextBranch; }; std::vector m_Entries; public: }; ``` ",
    "url": "/docs/project3/designing_nodes.html",
    "relUrl": "/docs/project3/designing_nodes.html"
  },"4": {
    "doc": "Home",
    "title": "CMSC 341 - Data Structures",
    "content": "This website will hold documentation for CMSC 341 Summer 2021. Unfortunately, as it is late in the session, you will only find project 3 here. ",
    "url": "/",
    "relUrl": "/"
  },"5": {
    "doc": "Home",
    "title": "Your work at a glance:",
    "content": "Project 3 ",
    "url": "/",
    "relUrl": "/"
  },"6": {
    "doc": "Home",
    "title": "Home",
    "content": " ",
    "url": "/",
    "relUrl": "/"
  },"7": {
    "doc": "Function Descriptions",
    "title": "Function Descriptions",
    "content": "{% assign project = site.data.project.project3 %} {% include due_date.html project=project%} {% if project.changelog %} {% include changelog.html project=project %} {% endif %} ",
    "url": "/docs/project3/function_descriptions/",
    "relUrl": "/docs/project3/function_descriptions/"
  },"8": {
    "doc": "Project 3: B is NOT for binary",
    "title": "Project 3: B is NOT for binary",
    "content": "# {{page.title}} {% assign project = site.data.project.project3 %} {% include due_date.html project=project%} {% if project.changelog %} {% include changelog.html project=project %} {% endif %} Please take your time in reading this website, and remember that there is always a search bar at the top of the site, so you can search the content faster! . ",
    "url": "/docs/project3/",
    "relUrl": "/docs/project3/"
  },"9": {
    "doc": "Introduction",
    "title": "Introduction",
    "content": "# {{page.title}} {% assign project = site.data.project.project3 %} {% include due_date.html project=project%} {% if project.changelog %} {% include changelog.html project=project %} {% endif %} In this project you will be implementing a B-Tree as an index for a database. A key reason to use a B-Tree is to avoid the performance penalty of storing part of your tree, as well as the actual data for the tree, on disc (or some other form of dense, persistent storage). Naturally, having you work with real databases or with disks (we are talking hardware here, not just file I/O) is a bit too much. To that end we will be faking most of it, with code that will be provided. You will have to make quite a few design choices this time as well. We will be providing some ideas and suggestions to get you started, but it is always better to implement something you understand, instead of following a suggestion blindly. It is always about pros and cons! . We will be using boxes like this one to draw your attention to things. There are many colors included! If something MUST be implemented in a specific way, we will let you know with a similar box as well. Please take your time in reading this website, and remember that there is always a search bar at the top of the site, so you can search the content faster! . ",
    "url": "/docs/project3/introduction.html",
    "relUrl": "/docs/project3/introduction.html"
  },"10": {
    "doc": "Out parameters",
    "title": "Out parameters",
    "content": "{% assign project = site.data.project.project3 %} {% include due_date.html project=project%} {% if project.changelog %} {% include changelog.html project=project %} {% endif %} # Project 3: {{page.title}} When you take a parameter by reference, you can treat it like a local, stack allocated variable, and the caller sees the changes you make. It is in essence a pointer, it just makes the syntax a bit simpler and you don't have to `->` everything. Let's see how we use out parameter to our advantage next. Let's say we are implementing BTree::try_find. You will notice that outIndex is a TIndex reference. It is **NOT** `const`. That means we can modify it in our function! Notice how `some_other_function` also takes a `TIndex&`. If you needed `some_other_function` to be recursive you can add additional arguments, and when you find what you are looking for, you just assign to the reference and return whatever you need to return. The return value could be a boolean, it could be the index where you found the thing, it could be many things. It depends on your design. ```c++ some_return_type some_other_function(TIndex& outIndex) { // Do work to find the index (ie this function could be recursive); if (found) outIndex = ...; return something; } bool try_find(const TKey& key, TIndex& outIndex) { // Example 1 outIndex = some_function(some_arguments); // Example 2 some_return_value = some_other_function(outIndex); } ``` ",
    "url": "/docs/project3/out_parameters.html",
    "relUrl": "/docs/project3/out_parameters.html"
  },"11": {
    "doc": "BTree::try_add",
    "title": "BTree::try_add",
    "content": "{% assign project = site.data.project.project3 %} {% include due_date.html project=project%} {% if project.changelog %} {% include changelog.html project=project %} {% endif %} # BTree::try_add ```c++ bool BTree::try_add(const TKey& key, const TIndex& inIndex) ``` ## Description Attempts to add a new element to the tree. You can assume that the key implements all of the standard operators (i.e. &gt;, &lt;, &geq;, &leq;, == ). You can also assume that there is a TKey == TIndex operator. ## Parameters * **key**: The key for this element * **inIndex**: The input element to be added to the tree ## Return If the element was added successfully the function should return true. If the element already exists, the function should return false **and not modify the tree**. In any other case the function should return false **and not modify the tree**. ",
    "url": "/docs/project3/function_descriptions/try_add.html",
    "relUrl": "/docs/project3/function_descriptions/try_add.html"
  },"12": {
    "doc": "BTree::try_delete",
    "title": "BTree::try_delete",
    "content": "{% assign project = site.data.project.project3 %} {% include due_date.html project=project%} {% if project.changelog %} {% include changelog.html project=project %} {% endif %} # BTree::try_delete ```c++ bool BTree::try_delete(const TKey& key) ``` ## Description Attempts to remove the element with the given key from the tree. If the key was not found, the function does not modify the tree **in any way**. If the element is found, you must update your structure to remove it. This heavily depends on how you've implemented things. You can assume that there is nothing special you need to do with the memory allocated for TIndex. You only care about the memory you have allocated in your code. You can assume that the key implements all of the standard operators (i.e. &gt;, &lt;, &geq;, &leq;, == ). You can also assume that there is a TKey == TIndex operator. ## Parameters * **key**: The key for this element * **inIndex**: The new values for the element ## Return If the element was found the function should return true. If the element does not exist, the function should return false. In any other case the function should return false. ",
    "url": "/docs/project3/function_descriptions/try_delete.html",
    "relUrl": "/docs/project3/function_descriptions/try_delete.html"
  },"13": {
    "doc": "BTree::try_find",
    "title": "BTree::try_find",
    "content": "{% assign project = site.data.project.project3 %} {% include due_date.html project=project%} {% if project.changelog %} {% include changelog.html project=project %} {% endif %} # BTree::try_find ```c++ bool BTree::try_find(const TKey& key, TIndex& outIndex) const ``` ## Description Attempts to find the element in the tree. If the key was not found, the function does not modify outIndex in any way. You can assume the TIndex assignment operator will be enough to copy the TIndex you found to outIndex. You can assume that the key implements all of the standard operators (i.e. &gt;, &lt;, &geq;, &leq;, == ). You can also assume that there is a TKey == TIndex operator. ## Parameters * **key**: The key for this element * **outIndex**: The output parameter ## Return If the element was found the function should return true, and set `outIndex` to the found element. If the element does not exist, the function should return false. In any other case the function should return false. ",
    "url": "/docs/project3/function_descriptions/try_find.html",
    "relUrl": "/docs/project3/function_descriptions/try_find.html"
  },"14": {
    "doc": "BTree::try_update",
    "title": "BTree::try_update",
    "content": "{% assign project = site.data.project.project3 %} {% include due_date.html project=project%} {% if project.changelog %} {% include changelog.html project=project %} {% endif %} # BTree::try_update ```c++ bool BTree::try_update(const TKey& key, const TIndex& inIndex) const ``` ## Description Attempts to update the element in the tree. If the key was not found, the function does not modify the tree **in any way**. If the element is found, you can assume that the assignment operator for TIndex will be enough to do the update for you. You can assume that the key implements all of the standard operators (i.e. &gt;, &lt;, &geq;, &leq;, == ). You can also assume that there is a TKey == TIndex operator. ## Parameters * **key**: The key for this element * **inIndex**: The new values for the element ## Return If the element was found the function should return true. If the element does not exist, the function should return false. In any other case the function should return false. ",
    "url": "/docs/project3/function_descriptions/try_update.html",
    "relUrl": "/docs/project3/function_descriptions/try_update.html"
  }
}
